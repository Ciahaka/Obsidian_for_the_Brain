Массив (**`Array`**) в JavaScript является глобальным объектом, который используется для создания массивов; которые представляют собой высокоуровневые списко-подобные объекты.
[MDN web docs](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)
```
'join', 'reverse', 'sort', 'push', 'pop', 'shift', 'unshift',
'splice', 'concat', 'slice', 'indexOf', 'lastIndexOf',
'forEach', 'map', 'reduce', 'reduceRight', 'filter',
'some', 'every'
```
[[#map]]
[[#filter]]
[[find]]
[[reduce]] - нахождение максимального значения
[[forEach]] - используется для перебора массива.
[[concat]] - объединение массивов
[[includes]] - поиск элемента в массиве
[[push]] - добавление элемента в конец массива
[[split]] - разбивает объект string на массив строк
[[indexOf]] - находит элемент в массиве по его индексу
[[slice]] - обрезает массив по индексу, возвращает новый массив
[[splice]]  добавляет или удаляет элементы из массива,, возвращает массив удалённых элементов
[[#every]] 
[[#some]]
[[join]] - объединяет элементы массива в строку
[[Array.isArray()]] - метод проверяющий объект на массив

#### map
[Mdn Web](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
[Map под капотом](https://youtu.be/kY6g2ofO_Qg?list=PLbLBXDhswD1ebx1pf31nXbW3VauIzAm3v&t=918)  [[#Метод map под капотом | вниз]]

Метод массива (Array) содержит в себе функцию callback (коллбэк функцию (анонимную стрелочную функцию)), и пробегая по элементам массива, вызывает эту функцию для каждого элемента по очереди. При этом метод map не мутирует исходный массив, а создаёт новый массив и записывает в него элементы с изменёнными значениями.
```javascript
const myArray = [1,2,3,4]
const myNewArray = myArray.map((el)=>(el*3))
```

Данная запись возвращает значение неявно, для явного возвращения нужно добавить фигурные скобки и return

##### Метод map под капотом
```js
const mupGlobal = (array, func) => {
   const result = []
   for(let i = 0; i < array.length; i++) {
      result [i] = func(array[i])
   }
  return result
}
```

1. Функция принимает в параметрах некий исходный массив, по которому будет проходить итерация, и callback функцию, которая будет применятся ко всем элементам исходного массива.
2. Метод map всегда создаёт новый массив, поэтому внутри нашей функции также создадим пустой массив и присвоим его значение переменной result.
3. Этот массив мы должны вернуть, как и метод map всегда возвращает новый массив. Поэтому прописываем return result.
4. Между переменной и return создаём цикл for, который пробежит по всем элементам исходного массива, для каждого из элементов применит нашу callback функцию func, а результат выполнения этой функции запишет в новый результирующий массив result.  Если дословно: 
``` javascript
result [i] = func(array[i]) 
```
 Примени func к каждому элементу [i] массива array и запиши эти элементы в новый массив result/
 
##### Итого
- Метод map всегда создаёт и возвращает новый массив
- количество элементов результирующего массива равно количеству элементов исходного массива.

#### filter
[Mdn Web](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
[Filter под капотом](https://youtu.be/kY6g2ofO_Qg?list=PLbLBXDhswD1ebx1pf31nXbW3VauIzAm3v&t=2822)     [[#Метод Filter под капотоm | вниз]]
Метод массива filter пробегает по всем элементам массива и передаёт один раз каждому элементу заданную callback функцию. В результате создаёт новый массив, в который помещает элементы исходного массива, для которых callback функция вернула значение равное true/ Остальные элементы пропускаются и не включаются в новый массив.
Не мутирует исходный массив!

##### Метод Filter под капотоm
``` javascript

const filterGlobal = (array,func) => {
  const result = []
  for(let i = 0; i < array.length; i++) {
     if(func(array[i]) === true) {
        result.push(array[i])
     }
  }
retturn result
}
```

1. Функция в параметрах получает некий массив, по которому будет проходить наш цикл, и callback функцию , которая будет применяться к элементам этого массива
2. Так как метод массива filter всегда создаёт новый массив, то и в функции создадим пустой массив, и назначим его переменной result/
3. Метод массива filter всегда возвращает новый массив, поэтому и наша функция должна вернуть массив result
4. Между переменной и return напишем цикл [[for]], который пробежит по элементам исходного массива и проверит, что если функция передаваемая в параметрах  возвращает true для элемента массива, то мы добавляем такой элемент в результирующий массив! ```
```javascript
result.push(array[i])
```
##### Итого
- Метод filter всегда возвращает новый массив.
- Количество элементов в новом массиве может быть от нуля до, не более длины исходного массива. Зависит от того сколько элементов исходного массива пройдут фильтрацию
- Все элементы результирующего массива представляют из себя элементы исходного массива. В процессе фильтрации не происходит каких либо преобразований.

#### [Mdn Web](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
[Find под капотом](https://youtu.be/kY6g2ofO_Qg?list=PLbLBXDhswD1ebx1pf31nXbW3VauIzAm3v&t=3556)  [[#Метод find под капотом | вниз]]
Метод массива find применят переданную функцию callback один раз для каждого, присутствующего в исходном массиве элемента, до тех пор пока она не вернёт true. Как только такой элемент массива найден , метод find возвращает этот элемент (его значение)

### Метод find под капотом
``` javascript
const findGlobal = (array, func) => {
  for(let i = 0; i < array.length; i ++) {
    if(func(array[i]) === true) {
      return array[i]
 }}}
```
1. Метод массива find не создаёт и не возвращает новый массив.  Метод `find` не изменяет массив, для которого он был вызван!!
2. Функция получает в параметрах некий исходный массив и callback функцию, которая будет применяться к элементам исходного массива.
3. Внутри функции создаём цикл [[for]], который пробежит по всем элементам  массива, применяя для каждого из них callback функцию func, и в случае результата true, просто ретурнет этот элемент массива.

#### every
Метод возвращает true если функция callback подойдёт для каждого элемента массива. Иначе вернёт false
`arr.every(callback[,thisArg])`

#### some
Метод возвращает true если функция callback подойдёт для хотя бы одного элемента массива. Иначе вернёт false
`arr.some(callback[,thisArg])`

