Это **чистая** функция преобразования! Поэтому, на преобразование, всегда отдаём копию исходного стейта. Отдаём в функцию reducer стейт и говорим - преобразуй стейт согласно заданным нами инструкциям (action).
Инструкции `action` создаются при помощи конструкции `switch`. 
Switch посмотрит какой тип в инструкции `.type` и выполнит один из `case`.
После преобразования наружу выйдет изменённый стейт.
Инструкция `action`, помимо `.type`, может содержать и другие данные (дополнительные)
Инструкция `action` - это отдельный объект и отдельная инструкция! Его свойства должны быть чётко заданы!

 - В проекте, для функции `reducer` нужно создать отдельную директорию. 
 - Файл для `reducer` задаётся с разрешением `ts`  а не `tsx`, так как нет разметки `jsx`.
 - В самом файле нужно задать типы для обрабатываемого стейта и для инструкции **`action`**.
 - Сам `reducer` создаётся при помощи стрелочной функции. В параметрах такой функции приходит стейт для обработки, и инструкция(объект) `action`. Там же, в параметрах. прописываем типы для стейта и экшона.
 - Помимо типизации входных данных можно(нужно) типизировать `return` функции!
   Это делается через двоеточие, за скобками входных параметров.
```ts
export const func = (st:type, action:type):StType => {...}
```

В теле функции размещается условная инструкция `switch`
```ts
switch(action.type){
  case 'bla-bla':
  default: throw new error ('bla-bla-bla-bla')
}
```
.type - это всегда некое строковое название

 - Составление экшонов за пределами функции редьюсера чревато ошибками, поэтому для создания экшонов специальная функция ActionCreator (AC). Такая функция размещается в том же файле, что и редьюсер. Под ним. название AC лучше писать с маленькой буквы.
 - Функция AC возвращает правильные объекты `action`. Объекты экшон мы экспортируем наружу, где необходимо вызываем функцию AC и в вызов кладём соответствующие параметры. Функция AC отдаёт экшон, и его мы отправляем в редьюсер.