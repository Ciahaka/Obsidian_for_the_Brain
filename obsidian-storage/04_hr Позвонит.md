[[#var, let, const]]  - различие способа объявления переменных.
[[#методы функций]]  - apply, bind, call, length.
[[#Рекурсивная функция |Рекурсия]] - функция вызывающая себя внутри себя же.
[[#Объект]] - что есть объект в js?
[[#Типы данных]] 
[[#Отличие === от ==]] -  отличие строго равенства от нестрогого.
[[#Замыкание]] 
[[#Само-вызывающаяся функция IIFE |IIFE функция, самовызыв...]] - ограничение области видимости логики.
[[#TDD]] - методология разработки написанием тестов.
[[#БЭМ методология]] - вёрстка интерфейса от Яндекс.
[[#HOC]] - функция, принимающая компонент и возвращающая его же в обёртке контейнера. Переиспользование логики .
[[#React.memo.]] - HOK улучшения производительности.
[[#Hook - принципы использования]] - правила использования хуков
[[#call, apply, bind]] - методы функции
[[#preventDefault]] - отменяет событие
[[#SOLID]] - набор принципов программирования
[[#Babel]] - транспилятор/компилятор
[[#CORS]] - политика безопасности браузера
[[#Разница: i + 1; i++; ++i|i + 1; i++; ++i ]] - разница в написании
[[#Async, Defer]] - атрибуты тега `script` , помогают скрипту не блокировать страницу браузера при её загрузке.
[[#Структура HTML документа]] - !DOCTYPE html; html; head; body; header
[[#LIFO FIFO]] - структуры данных Stack и Очередь

[1:36](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=96s) куки
[4:17](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=257s) ООП 
[7:20](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=440s) [SOLID](obsidian://open?vault=obsidian-storage&file=%D0%A2%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D1%8B%2FM%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%2F%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) ( S )
[8:33](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=513s) O(n)
[13:40](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=820s) local and session storage 
[15:57](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=957s) Agile Waterfall
[1:42](https://www.youtube.com/watch?v=IZPS8mGco-0&t=102s) - буква О в SOLID
[3:27](https://www.youtube.com/watch?v=IZPS8mGco-0&t=207s) - диапазоны http статусов
[6:09](https://www.youtube.com/watch?v=IZPS8mGco-0&t=369s) - соотношение CRUD к типам http запросов
[13:40](https://www.youtube.com/watch?v=IZPS8mGco-0&t=820s) - странный вопрос))))
[17:50](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1070s) - отличие http1 от http2
[20:25](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1225s) - что такое DNS
[23:27](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1407s) - что такое CDN
[27:15](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1635s) - что такое event loop
[3:57](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=237s) - что такое вебсокет
[8:56](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=536s) - try catch finally
[15:33](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=933s) - для чего нужен Promise.all
[18:21](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1101s) - жизненные циклы классовых компонент
[22:15](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1335s) - sql vs nosql
[26:13](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1573s) - что такое node.js
[30:52](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1852s) - async await
[32:57](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1977s) - зачем вначале файла пишем import React
[36:00](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=2160s) - принципы чистой функции
[38:32](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=2312s) - зачем нужен метод addEventListener
[3:35](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=215s) -  методы массива 
[4:52](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=292s) - git
[16:23](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=983s) - microtask vs macrotask
[19:26](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1166s) - map vs forEach
[24:52](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1492s) - отличие прото от Прототайп
[27:20](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1640s) - каррирование [Learn JS](https://learn.javascript.ru/currying-partials), частичное применение функции
[32:20](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1940s) - что такое баблинг (всплытие событий)


#### методы функций
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=182s) 
По сути, функция является объектом, поэтому у неё тоже могут быть методы, как и объекта.
К методам функции можно обратиться с помощью точечной записи. 
- length - метод который говорит о том сколько аргументов принимает функция.
- apply - [[apply|подробнее]] применить функцию (запустить её) с определённым контекстом, один из основных методов функции
- bind - [[bind | подробнее]] создаёт копию функции один из основных методов функции
- call -[[call|подробнее]] позвонить функции(вызвать её), один из основных методов функции

#### var, let, const
[Youtube](https://www.youtube.com/watch?v=Yt9UbMmAKXc&list=PLVfMKQXDAhGXmKZO1n72nkzB6QrgnPY3q&ab_channel=WebDeveloperBlog)
У var область видимости функциональная.  Хостинг var - всплытие. К этой переменной можно обратиться независимо от места её объявления.
При использовании var можно объявить две переменные с одинаковыми именами и разными значениями, с let это не прокатит
У let и const область видимости - блочная.
Значение let можно переопределить. Значение const переопределить нельзя, за исключением когда значением переменной является объект. ВУ этом случае, значение свойств объекта можно изменить.

#### Рекурсивная функция
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=264s) рекурсия - это функция, которая вызывает себя внутри себя же. Если её не прервать, то она будет крутиться вечно (пока не зависнет браузер и не выкинет ошибку). Поэтому нужно предусматривать условия (инструкции), при которых рекурсивная функция прекратит свою работу.
Пример использования рекурсивной функции: обход древовидных структур (папки со вложенными в них папками), глубокое копирование
```js
const test = () => {
test()
}
```
Прервать функцию условием:
```js
let i = 0
const test = () => {
console.log('test')
 i++
	if(i===10) {
		return
	}
test()
}
```

#### Объект
[Youtube](https://youtu.be/n9E-6aBcyd8?t=124) объекты (они же ассоциативные массивы) - набор свойств. Каждое свойство состоит из имени и значения. Объект - самостоятельная единица имеющая свойства и определённый тип.
Свойство объекта можно понимать как переменную закреплённую за объектом.
Метод объекта - это свойство объекта, являющееся функцией (map, filter....)

#### Типы данных
Существует 7 типов данных!
6 из них являются примитивами:
- **boolean** (булев, логический тип);
- **null** (объект тип);
	- Значение `null` представляет отсутствие какого-либо объектного значения, записывается литералом `null`.
        `null` является определённым значением отсутствия объекта, тогда как [`undefined`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined) обозначает неопределённость.
- **undefined** (неопределенно)
- **number** (число);
- **string** (строка);
- **symbol** (symbol, тип данных экземпляры которого уникальны и неизменяемы)
7-ым типом данных является объект.
**Object** -  набор свойств. Значение свойств могут иметь любой тип, включая другие объекты. Это позволяет строить сложные иерархии данных. Каждое свойство объекта идентифицируется ключом

#### Отличие === от ==
[Dimich](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=819s)  Операторы равенства. Оператор == сравнивает на равенство и приводит сравниваемые значения к единому типу. 
Оператор === сравнивает на идентичность. Не приводит сравниваемые значения к одному типу.

#### Замыкание
[Dimich](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=578s) замыкание это возможность функции обратиться ко внешнему лексическому окружению.
Можно сказать что замыкание - это функция в функции (внутренняя функция).
При выполнении родительской функции всё ещё можно обратиться к выполнению кода в дочерней функции.

#### Само-вызывающаяся функция IIFE
[Dimich](https://www.youtube.com/watch?v=IZPS8mGco-0&t=480s) 
IIFE - Immediately Invoked Function Expression (Выражение немедленно вызываемой функции)
- функция без имени, заключённая в круглые скобки. И вызывающими скобками за самой функцией. Служит для ограничения видимости логики, заключённой в теле функции.
(модульность кода).
 
Помогает избежать замусоривание кода и переприсваивание значений при работе в команде.
В настоящее время используется редко, так как современные компиляторы, упаковщики оборачивают всё в подобные функции за нас.
```js
(func (){
	console.log('test')
	let a = 25
	return {a}
})()
```

```js 
(() => {                      // стрелочная
	console.log('test')
	let a = 25
	return {a}
})()
```

#### TDD
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=750s) 
Test Driven Development (разработка через тестирование)  - методология разработки, при которой вначале пишут тест, и уже после пишут код, удовлетворяющий этот тест.
Такой подход помогает избежать множество непредвиденных ошибок ещё на стадии разработки. 
На стадии тестирования продукта, перед релизом, встреченные тестировщиками ошибки легче будет найти и пофиксить, не тратя на это уйму времени.
Так же эта методология позволяет создавать документацию к проекту по ходу проектирования.
Из минусов - изначальна затрачивается больше времени на разработку (но в последствии оно нивелируется малым временем отладки).

#### БЭМ методология
[Dimich](https://www.youtube.com/watch?v=IZPS8mGco-0&t=708s) 
[[БЭМ]] - подробно о методологии

#### HOC
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=425s) 
[React Doc](https://ru.reactjs.org/docs/higher-order-components.html)
[Kabzda](https://samurai.it-incubator.ru/pc/video-content/watch/60b51f6df084890015872def)
Компонент высшего порядка (Higher-Order Component)
Функция которая принимает на входе оригинальный компонент и возвращает оригинальный компонент обёрнутый в контейнер (компонент обёртку).
Используется для того, чтобы можно было переиспользовать логику. Для того, чтобы не дублировать код.
Сама логика зашивается в контейнер, и на вход можно подавать различные компоненты. И все подаваемые компоненты будут переиспользовать логику упакованную в контейнер.
HOC - всегда чистая функция! Он ничего не меняет  и не наследует поведение оборачиваемого компонента!
Оригинальный  компонент получает все пропсы переданные контейнеру.

Самый актуальный HOK на сегодня - 
##### React.memo.
[React Doc](https://ru.reactjs.org/docs/react-api.html#reactmemo)
[Kabzda](https://samurai.it-incubator.ru/pc/video-content/watch/60b51f6df084890015872def)
[01:31] - термины и понятия
[03:09] - о /
Он, на основе приходящих в оригинальный компонент, через контейнер, пропсов, решает нужна ли перерисовка оригинального компонента или нет. 
```js
const MyComponent = React.memo(function MyComponent(props) {
  /* рендер с использованием пропсов */
});
```
Пригоден для компонент, которые на основании одних и тех же пропсов рендерит одно и тоже. В этом случае, React, при использовании memo, будет брать результат последнего рендера компонента вместо того, чтобы его отрисовывать вновь. Улучшение производительности.

#### Hook - принципы использования
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=525s) 
[React Doc](https://ru.reactjs.org/docs/hooks-rules.html)
1. Использовать хуки только на верхнем уровне (только в react-функциях, компонентах), до return из них.
   Нельзя вызывать хуки внутри циклов или условных инструкций. в этом случае хуки могут не вызваться при последующем рендере. Для React важен порядок хуков, а дело до хука внутри цикла может и не дойти, и нарушится порядок.
2. Хуки можно вызывать внутри функциональных компонент, либо внутри других кастомных хуков.


#### call, apply, bind
[Dimich](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1767s) 
Метод **apply()** вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта)
Основное отличие от метода функции [[call]] состоит в том, что apply принимает в качестве аргументов единичный массив аргументов, а метод call - принимает список аргументов

`fun.apply(thisArg, [argsArray])`

Метод **call()** вызывает функцию с указанным значением `this` и индивидуально предоставленными аргументами.

`fun.call(thisArg[, arg1[, arg2[, ...]]])`

Вы можете присваивать различные объекты `this` при вызове существующей функции. `this` ссылается на текущий объект, вызвавший объект. С помощью `call` вы можете написать метод один раз, а затем наследовать его в других объектах, без необходимости переписывать метод для каждого нового объекта.

Метод функции **bind()** создаёт копию функции
``` javascript
function a() = alert('Привет!')    // Привет!
b = a.bind({})   // Привет!
```
 


#### preventDefault
[Подробнее](obsidian://open?vault=obsidian-storage&file=3_JS%2FDOM%2FpreventDefault())

#### SOLID
[Подробнее -->](obsidian://open?vault=obsidian-storage&file=3_JS%2FM%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%2F%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
#### Babel
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=672s) 
Переводит [[ECMAScript]] последней версии в более ранние. это необходимо для поддержки работоспособности старых версий браузеров, иначе код написанный с использование современных фич не сможет запускаться и работать в этих браузерах.

Babel в среде React компилирует язык JSX в понятный браузерам JS

Babel поддерживает типизацию, работает быстрее встроенного компилятора TS

#### CORS
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=1133s) 
[MDN Web](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)
**Cross-Origin Resource Sharing** (Совместное использование ресурсов между источниками) или Безопасность кросс-доменных запросов
Политика безопасности браузера. Защита от меж-скриптовой атаки. 

Браузер защищается при помощи политики CORS от  меж-доменных запросов. Если домен A  не разрешает присылать запросы с домена B, то браузер не пропустит подобный запрос. Можно предварительно отправлять запрос  `options`, ответом на который будет тип запросов разрешённых сервером.

#### Разница: i + 1; i++; ++i
`i+1` - возвращает значение i+1.  
`i++` - увеличивает значение i на 1, возвращает значение i до увеличения.  
`++i` - увеличивает значение i на 1, возвращает новое значение i.
```js
let i = 5
i + 1 // 6
i++   // 5
++i   // 6
```
Разницы в записи между ++i и i++ нет (первый вариант работает чуть быстрее). Дело вкуса.

#### Async, Defer
Это атрибуты тега `<script>`, Помогают браузеру корректно обрабатывать страницу(загружать скрипты и отрисовывать DOM элементы)  и не блокировать её при отрисовки 

##### defer
[defer - Learn JS](https://learn.javascript.ru/script-async-defer#defer)
Атрибут `defer` сообщает браузеру, что тот должен обрабатывать страницу, загружая `<script>` в фоновом режиме и запустить его только тогда, когда DOM дерево будет полностью построено.
Скрипты с атрибутом `defer` никогда не блокируют страницу при загрузке.
Скрипты с атрибутом `defer` всегда выполняются после того как отрисуется DOM дерево, но до момента события `DOMContentLoaded`!
**`DOMContentLoaded`** - событие документа, когда HTML полностью загружен и DOM документа доступен готов к работе.
Атрибут `defer` доступен только для внешних скриптов, если в теге `<script>` нет `src`, то атрибут будет проигнорирован.

##### async
[async - Learn JS](https://learn.javascript.ru/script-async-defer#async)
Атрибут `async` говорит, что скрипт, его несущий - абсолютно независим. Скрипты с этим атрибутом не ждут загрузки других скриптов и скриптов с `async` же! 
Событие `DOMContentLoaded` может наступить ранее скрипта с атрибутом, а может и позже.
Скрипт с атрибутом `async` не блокирует загрузку страницы и содержимое страницы отображается сразу.
Все скрипты выполняются в порядке загрузки.
Удобно для подключения сторонних скриптов (счётчиков, рекламы.)

#### Структура HTML документа
[[Структура HTML документа]] - подробно
#### LIFO FIFO
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=1288s)
[Доступно и подробно](https://webdevblog.ru/stek-i-ochered-v-javascript/)
Структуры данных. 
Есть разницы в производительности между стеком и очередью. Обуславливается это применяемыми методами: pop и push имеют сложность О(1), а метод shift - O(n)
Нужно помнить об ещё одной структуре данных - Куча (*heap*)
##### LIFO (Last In First Out) - последний пришёл, первый вышел.
Линейная структура последовательных и упорядоченных элементов - называется ***STACK*** (пример - накопление стопки тарелок)
Структура Stack выполняет несколько операций: *Push* (вставка или перемещение эл-та в стеке); *Pop* (удаление самого последнего л-та стека); *isEmpty* (проверяет пуст ли стек); *Peek* (возвращает верхний эл-т, без изменения самого стека)
Стек может работать с массивами или связанными списками. Предпочтительнее - массивы, так как производительность выше.
![[Pasted image 20230105212639.png]]
##### FIFO (First In First Out) - первый пришёл, первым ушёл
Линейная структура последовательных и упорядоченных элементов - называется ***Очередь*** (пример - очередь в магазине)
Структура Очередь обладает двумя основными операциями: *enqueue* (отвечает за вставку или отправку нового эл-та в очередь); *dequeue* (удаление первого эл-та очереди)
В JavaScript есть уже готовый метод удаления первого элемента массива, которым является метод массива [shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift).
![[Pasted image 20230105213639.png]]

##### HEAP или Куча
[О куче. Engl](https://blog.bitsrc.io/implementing-heaps-in-javascript-c3fbf1cb2e65)
Изначально не поддерживается JS
![[Pasted image 20230105215037.png]]
Выделение памяти для организации данных в виде дерева.
Если узел А является родителем узла Б, то ключ узла А больше или равен узлу ключа Б
Куча используется для получения элемента с наивысшим приоритетом (минимального или максимального) в любой момент времени. Существует два типа кучи в зависимости от свойства кучи — MinHeap и MaxHeap.
*MinHeap*: родительский узел всегда меньше дочерних узлов.
*MaxHeap*: родительский узел всегда больше или равен дочерним узлам.
Производительность кучи при получении элемента - О(1)
