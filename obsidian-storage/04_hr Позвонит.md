[[#var, let, const]]  - различие способа объявления переменных.
[[#методы функций]]  - apply, bind, call, length.
[[#Рекурсивная функция |Рекурсия]] - функция вызывающая себя внутри себя же.
[[#Объект]] - что есть объект в js?
[[#Типы данных]] 
[[#Отличие === от ==]] -  отличие строго равенства от нестрогого.
[[#Замыкание]] 
[[#Само-вызывающаяся функция IIFE |IIFE функция, самовызыв...]] - ограничение области видимости логики.
[[#TDD]] - методология разработки написанием тестов.
[[#БЭМ методология]] - вёрстка интерфейса от Яндекс.
[[#HOC]] - функция, принимающая компонент и возвращающая его же в обёртке контейнера. Переиспользование логики .
[[#React.memo.]] - HOK улучшения производительности.
[[#Hook - принципы использования]] - правила использования хуков
[[#call, apply, bind]] - методы функции
[[#preventDefault]] - отменяет событие
[[#SOLID]] - набор принципов программирования
[[#Babel]] - транспилятор/компилятор
[[#CORS]] - политика безопасности браузера
[[#Разница: i + 1; i++; ++i|i + 1; i++; ++i ]] - разница в написании
[[#Async, Defer]] - атрибуты тега `script` , помогают скрипту не блокировать страницу браузера при её загрузке.
[[#Структура HTML документа]] - !DOCTYPE html; html; head; body; header
[[#LIFO FIFO]] - структуры данных Stack и Очередь
[[#Virtual DOM]] - упрощённая легковесная копия [[DOM]]. оптимизация отрисовок.
[[#Node JS]] - платформа, среда разработки JS. Движок V8
[[#Swagger]] - автоматическое создание документации для API проекта
[[#Бинарный поиск]] - многократное разбиение отсортированного массива пополам. O (log 2 n)
[[#Сложность алгоритмов]] 
[[#two-way binding]] - двустороннее связывание.
[[#Хранение данных в браузере|local storage,  session storage, кэш, куки]] - хранение данных в браузере
[[#document.querySelector]] - прямой доступ к DOM элементу
[[#Agile VS Waterfall]] - методы ведения разработки
[[#Генератор]] - функция позволяющая возвращать разные значения по мере необходимости
[[#Коллекции Map и SET]] - ключи разных типов / коллекция уникальных значений без ключей
[[#Методы for in и for of]]
[[#boxing и unboxing]] - упаковка в объект и распаковка из него.
[[#Hash таблица]] -структура данных а-ля ассоциативный массив 
[[#Кэширование]] - браузер сохраняет результат обращения к серверу
[[#Инвалидность кэша]] - невалидность данных браузера и сервера
[[#Мемоизация]] - способность запоминать результат работы функции

[4:17](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=257s) ООП 
[3:27](https://www.youtube.com/watch?v=IZPS8mGco-0&t=207s) - диапазоны http статусов
[6:09](https://www.youtube.com/watch?v=IZPS8mGco-0&t=369s) - соотношение CRUD к типам http запросов
[13:40](https://www.youtube.com/watch?v=IZPS8mGco-0&t=820s) - странный вопрос))))
[17:50](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1070s) - отличие http1 от http2
[20:25](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1225s) - что такое DNS
[23:27](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1407s) - что такое CDN
[27:15](https://www.youtube.com/watch?v=IZPS8mGco-0&t=1635s) - что такое event loop [habr](https://habr.com/ru/post/461401/) [Ulbi](https://www.youtube.com/watch?v=zDlg64fsQow)
[3:57](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=237s) - что такое вебсокет
[8:56](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=536s) - try catch finally
[15:33](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=933s) - для чего нужен Promise.all
[18:21](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1101s) - жизненные циклы классовых компонент
[22:15](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1335s) - sql vs nosql
[30:52](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1852s) - async await
[32:57](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1977s) - зачем вначале файла пишем import React
[36:00](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=2160s) - принципы чистой функции
[38:32](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=2312s) - зачем нужен метод addEventListener
[3:35](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=215s) -  методы массива 
[4:52](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=292s) - git
[16:23](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=983s) - microtask vs macrotask
[19:26](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1166s) - map vs forEach
[24:52](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1492s) - отличие прото от Прототайп
[27:20](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1640s) - каррирование [Learn JS](https://learn.javascript.ru/currying-partials), частичное применение функции
[32:20](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1940s) - что такое баблинг (всплытие событий)
[0:38](https://www.youtube.com/watch?v=saDuFtwxL4U&t=38s) - зачем нужен PATCH, если есть PUT 
[6:06](https://www.youtube.com/watch?v=saDuFtwxL4U&t=366s) - назовите минимум 2 принципа ООП
[11:55](https://www.youtube.com/watch?v=saDuFtwxL4U&t=715s) - наследование
[18:32](https://www.youtube.com/watch?v=saDuFtwxL4U&t=1112s) - во что babel превращает jsx
[21:30](https://www.youtube.com/watch?v=saDuFtwxL4U&t=1290s) - React.createContext
[24:46](https://www.youtube.com/watch?v=saDuFtwxL4U&t=1486s) - чем отличается Flux от Redux
[27:27](https://www.youtube.com/watch?v=saDuFtwxL4U&t=1647s) - в чем фишка наследоваться от React.PureComponent вместо React.Component
[29:55](https://www.youtube.com/watch?v=saDuFtwxL4U&t=1795s) - перечислите методы жизненного цикла в правильном порядке
[2:28](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=148s) - Расшифруй все буквы аббревиатуры SOLID?
[7:26](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=446s) - Что такое принцип DRY?
[9:36](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=576s) - Что такое принцип KISS?
[12:35](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=755s) - Отличие библиотеки от фреймворка
[18:50](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=1130s) - Что такое SPA и в чём суть?
[26:55](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=1615s) - Что такое PWA?
[36:06](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=2166s) - Что такое SEO и почему SPA для SEO не очень?
[1:02:12](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=3732s) - Что такое XSS-атака?

#### методы функций
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=182s) 
По сути, функция является объектом, поэтому у неё тоже могут быть методы, как и объекта.
К методам функции можно обратиться с помощью точечной записи. 
- length - метод который говорит о том сколько аргументов принимает функция.
- apply - [[apply|подробнее]] применить функцию (запустить её) с определённым контекстом, один из основных методов функции
- bind - [[bind | подробнее]] создаёт копию функции один из основных методов функции
- call -[[call|подробнее]] позвонить функции(вызвать её), один из основных методов функции

#### var, let, const
[Youtube](https://www.youtube.com/watch?v=Yt9UbMmAKXc&list=PLVfMKQXDAhGXmKZO1n72nkzB6QrgnPY3q&ab_channel=WebDeveloperBlog)
У var область видимости функциональная.  Хостинг var - всплытие. К этой переменной можно обратиться независимо от места её объявления.
При использовании var можно объявить две переменные с одинаковыми именами и разными значениями, с let это не прокатит
У let и const область видимости - блочная.
Значение let можно переопределить. Значение const переопределить нельзя, за исключением когда значением переменной является объект. В этом случае, значение свойств объекта можно изменить.

#### Рекурсивная функция
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=264s) 
[freeCodeCamp](https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-use-recursion-to-create-a-countdown/305925)
Рекурсия - это функция, которая вызывает себя внутри себя же. Если её не прервать, то она будет крутиться вечно (пока не зависнет браузер и не выкинет ошибку). Поэтому нужно предусматривать условия (инструкции), при которых рекурсивная функция прекратит свою работу.
Пример использования рекурсивной функции: обход древовидных структур (папки со вложенными в них папками), глубокое копирование
```js
const test = () => {
test()
}
```
Прервать функцию условием:
```js
let i = 0
const test = () => {
console.log('test')
 i++
	if(i===10) {
		return
	}
test()
}
```

#### Объект
[Youtube](https://youtu.be/n9E-6aBcyd8?t=124) объекты (они же ассоциативные массивы) - набор свойств. Каждое свойство состоит из имени и значения. Объект - самостоятельная единица имеющая свойства и определённый тип.
Свойство объекта можно понимать как переменную закреплённую за объектом.
Метод объекта - это свойство объекта, являющееся функцией (map, filter....)

#### Типы данных
Существует 7 типов данных!
6 из них являются примитивами:
- **boolean** (булев, логический тип);
- **null** (объект тип);
	- Значение `null` представляет отсутствие какого-либо объектного значения, записывается литералом `null`.
        `null` является определённым значением отсутствия объекта, тогда как [`undefined`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/undefined) обозначает неопределённость.
- **undefined** (неопределенно)
- **number** (число);
- **string** (строка);
- **symbol** (symbol, тип данных экземпляры которого уникальны и неизменяемы)
7-ым типом данных является объект.
**Object** -  набор свойств. Значение свойств могут иметь любой тип, включая другие объекты. Это позволяет строить сложные иерархии данных. Каждое свойство объекта идентифицируется ключом

#### Отличие === от ==
[Dimich](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=819s)  Операторы равенства. Оператор == сравнивает на равенство и приводит сравниваемые значения к единому типу. 
Оператор === сравнивает на идентичность. Не приводит сравниваемые значения к одному типу.

#### Замыкание
[Dimich](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=578s) замыкание это возможность функции обратиться ко внешнему лексическому окружению.
Можно сказать что замыкание - это функция в функции (внутренняя функция).
При выполнении родительской функции всё ещё можно обратиться к выполнению кода в дочерней функции.

#### Само-вызывающаяся функция IIFE
[Dimich](https://www.youtube.com/watch?v=IZPS8mGco-0&t=480s) 
IIFE - Immediately Invoked Function Expression (Выражение немедленно вызываемой функции)
- функция без имени, заключённая в круглые скобки. И вызывающими скобками за самой функцией. Служит для ограничения видимости логики, заключённой в теле функции.
(модульность кода).
 
Помогает избежать замусоривание кода и переприсваивание значений при работе в команде.
В настоящее время используется редко, так как современные компиляторы, упаковщики оборачивают всё в подобные функции за нас.
```js
(func (){
	console.log('test')
	let a = 25
	return {a}
})()
```

```js 
(() => {                      // стрелочная
	console.log('test')
	let a = 25
	return {a}
})()
```

#### TDD
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=750s) 
Test Driven Development (разработка через тестирование)  - методология разработки, при которой вначале пишут тест, и уже после пишут код, удовлетворяющий этот тест.
Такой подход помогает избежать множество непредвиденных ошибок ещё на стадии разработки. 
На стадии тестирования продукта, перед релизом, встреченные тестировщиками ошибки легче будет найти и пофиксить, не тратя на это уйму времени.
Так же эта методология позволяет создавать документацию к проекту по ходу проектирования.
Из минусов - изначальна затрачивается больше времени на разработку (но в последствии оно нивелируется малым временем отладки).

#### БЭМ методология
[Dimich](https://www.youtube.com/watch?v=IZPS8mGco-0&t=708s) 
[[БЭМ]] - подробно о методологии

#### HOC
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=425s) 
[React Doc](https://ru.reactjs.org/docs/higher-order-components.html)
[Kabzda](https://samurai.it-incubator.ru/pc/video-content/watch/60b51f6df084890015872def)
Компонент высшего порядка (Higher-Order Component)
Функция которая принимает на входе оригинальный компонент и возвращает изменённый компонент обёрнутый в контейнер (компонент обёртку).
Используется для того, чтобы можно было переиспользовать логику. Для того, чтобы не дублировать код.
Сама логика зашивается в контейнер, и на вход можно подавать различные компоненты. И все подаваемые компоненты будут переиспользовать логику упакованную в контейнер.
HOC - всегда чистая функция! Он ничего не меняет  и не наследует поведение оборачиваемого компонента!
Оригинальный  компонент получает все пропсы переданные контейнеру.

Самый актуальный HOK на сегодня - 
##### React.memo.
[React Doc](https://ru.reactjs.org/docs/react-api.html#reactmemo)
[Kabzda](https://samurai.it-incubator.ru/pc/video-content/watch/60b51f6df084890015872def)
[01:31] - термины и понятия
[03:09] - о .memo, Virtual DOM, DOM, производительность
[12:27] - мемоизация, кэширование, инвалидация кэша
[11:22 + 16:50] - практика в storybook
[35:35] - итого


Он, на основе приходящих в оригинальный компонент, через контейнер, пропсов, решает нужна ли перерисовка оригинального компонента или нет. 
```js
const MyComponent = React.memo(function MyComponent(props) {
  /* рендер с использованием пропсов */
});
```
Пригоден для компонент, которые на основании одних и тех же пропсов рендерит одно и тоже. В этом случае, React, при использовании memo, будет брать результат последнего рендера компонента вместо того, чтобы его отрисовывать вновь. Улучшение производительности.

##### Кэширование
Это технология при которой браузер сохраняет у себя результат первичного запроса на сервер (картинки, треки...), и при последующем аналогичном запросе браузер уже не обращается к серверу, а отдаёт сохранённый результат.
Данная технология улучшает производительность!

##### Инвалидность кэша
Минусом кэширования является то, что сервера периодически обновляют данные, и сохранённые в кэше браузера данные могут быть неактуальны на момент нового запроса.
Чтобы избежать подобных ситуаций нужно периодически обновлять кэш браузера (производить валидацию кэша)

##### Мемоизация
Технология очень схожая по принципу с кэшированием, но в случае с функцией. Мемоизация позволяет сохранять результат работы функции и при следующем обращение(вызове) функции использовать сохранённый результат, а не запускать саму функцию.
Улучшает производительность!


#### Hook - принципы использования
[Dimich](https://www.youtube.com/watch?v=HhrlLqDCQ40&t=525s) 
[React Doc](https://ru.reactjs.org/docs/hooks-rules.html)
1. Использовать хуки только на верхнем уровне (только в react-функциях, компонентах), до return из них.
   Нельзя вызывать хуки внутри циклов или условных инструкций. в этом случае хуки могут не вызваться при последующем рендере. Для React важен порядок хуков, а дело до хука внутри цикла может и не дойти, и нарушится порядок.
2. Хуки можно вызывать внутри функциональных компонент, либо внутри других кастомных хуков.

#### call, apply, bind
[Dimich](https://www.youtube.com/watch?v=MkZS4V8xUtA&t=1767s) 
##### apply()
Метод **apply()** вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта)
Основное отличие от метода функции call() состоит в том, что apply принимает в качестве аргументов единичный массив аргументов, а метод call - принимает список аргументов

```js
fun.apply(thisArg, [argsArray])
```

##### call()
Метод **call()** вызывает функцию с указанным значением `this` и индивидуально предоставленными аргументами.
```js
fun.call(thisArg[, arg1[, arg2[, ...]]])
```

Вы можете присваивать различные объекты `this` при вызове существующей функции. `this` ссылается на текущий объект, вызвавший объект. С помощью `call` вы можете написать метод один раз, а затем наследовать его в других объектах, без необходимости переписывать метод для каждого нового объекта.

##### bind()
[learn JS](https://learn.javascript.ru/bind)
Метод функции **bind()** создаёт копию (новую функцию) функции.
``` javascript
function a() = alert('Привет!')    // Привет!
b = a.bind({})   // Привет!
```
 При передаче методов в качестве callback может произойти потеря this. Происходит это всегда в момент, когда метод передаётся отдельно от объекта. 
 **bind()** позволяет привязать передаваемому методу контекст вызова.


#### preventDefault
[Подробнее](obsidian://open?vault=obsidian-storage&file=3_JS%2FDOM%2FpreventDefault())

#### SOLID
[Подробнее -->](obsidian://open?vault=obsidian-storage&file=M%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%2F%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
#### Babel
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=672s) 
Переводит [[ECMAScript]] последней версии в более ранние. это необходимо для поддержки работоспособности старых версий браузеров, иначе код написанный с использование современных фич не сможет запускаться и работать в этих браузерах.

Babel в среде React компилирует язык JSX в понятный браузерам JS

Babel поддерживает типизацию, работает быстрее встроенного компилятора TS

#### CORS
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=1133s) 
[MDN Web](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)
**Cross-Origin Resource Sharing** (Совместное использование ресурсов между источниками) или Безопасность кросс-доменных запросов
Политика безопасности браузера. Защита от меж-скриптовой атаки. 

Браузер защищается при помощи политики CORS от  меж-доменных запросов. Если домен A  не разрешает присылать запросы с домена B, то браузер не пропустит подобный запрос. Можно предварительно отправлять запрос  `options`, ответом на который будет тип запросов разрешённых сервером.

#### Разница: i + 1; i++; ++i
`i+1` - возвращает значение i+1.  
`i++` - увеличивает значение i на 1, возвращает значение i до увеличения.  
`++i` - увеличивает значение i на 1, возвращает новое значение i.
```js
let i = 5
i + 1 // 6
i++   // 5
++i   // 6
```
Разницы в записи между ++i и i++ нет (первый вариант работает чуть быстрее). Дело вкуса.

#### Async, Defer
Это атрибуты тега `<script>`, Помогают браузеру корректно обрабатывать страницу(загружать скрипты и отрисовывать DOM элементы)  и не блокировать её при отрисовки 

##### defer
[defer - Learn JS](https://learn.javascript.ru/script-async-defer#defer)
Атрибут `defer` сообщает браузеру, что тот должен обрабатывать страницу, загружая `<script>` в фоновом режиме и запустить его только тогда, когда DOM дерево будет полностью построено.
Скрипты с атрибутом `defer` никогда не блокируют страницу при загрузке.
Скрипты с атрибутом `defer` всегда выполняются после того как отрисуется DOM дерево, но до момента события `DOMContentLoaded`!
**`DOMContentLoaded`** - событие документа, когда HTML полностью загружен и DOM документа доступен готов к работе.
Атрибут `defer` доступен только для внешних скриптов, если в теге `<script>` нет `src`, то атрибут будет проигнорирован.

##### async
[async - Learn JS](https://learn.javascript.ru/script-async-defer#async)
Атрибут `async` говорит, что скрипт, его несущий - абсолютно независим. Скрипты с этим атрибутом не ждут загрузки других скриптов и скриптов с `async` же! 
Событие `DOMContentLoaded` может наступить ранее скрипта с атрибутом, а может и позже.
Скрипт с атрибутом `async` не блокирует загрузку страницы и содержимое страницы отображается сразу.
Все скрипты выполняются в порядке загрузки.
Удобно для подключения сторонних скриптов (счётчиков, рекламы.)

#### Структура HTML документа
[[Структура HTML документа]] - подробно
#### LIFO FIFO
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=1288s)
[Доступно и подробно](https://webdevblog.ru/stek-i-ochered-v-javascript/)
Структуры данных. 
Есть разницы в производительности между стеком и очередью. Обуславливается это применяемыми методами: pop и push имеют сложность О(1), а метод shift - O(n)
Нужно помнить об ещё одной структуре данных - Куча (*heap*)
##### LIFO (Last In First Out) - последний пришёл, первый вышел.
Линейная структура последовательных и упорядоченных элементов - называется ***STACK*** (пример - накопление стопки тарелок)
Структура Stack выполняет несколько операций: *Push* (вставка или перемещение эл-та в стеке); *Pop* (удаление самого последнего л-та стека); *isEmpty* (проверяет пуст ли стек); *Peek* (возвращает верхний эл-т, без изменения самого стека)
Стек может работать с массивами или связанными списками. Предпочтительнее - массивы, так как производительность выше.
![[Pasted image 20230105212639.png]]
##### FIFO (First In First Out) - первый пришёл, первым ушёл
Линейная структура последовательных и упорядоченных элементов - называется ***Очередь*** (пример - очередь в магазине)
Структура Очередь обладает двумя основными операциями: *enqueue* (отвечает за вставку или отправку нового эл-та в очередь); *dequeue* (удаление первого эл-та очереди)
В JavaScript есть уже готовый метод удаления первого элемента массива, которым является метод массива [shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift).
![[Pasted image 20230105213639.png]]

##### HEAP или Куча
[О куче. Engl](https://blog.bitsrc.io/implementing-heaps-in-javascript-c3fbf1cb2e65)
Изначально не поддерживается JS
![[Pasted image 20230105215037.png]]
Выделение памяти для организации данных в виде дерева.
Если узел А является родителем узла Б, то ключ узла А больше или равен узлу ключа Б
Куча используется для получения элемента с наивысшим приоритетом (минимального или максимального) в любой момент времени. Существует два типа кучи в зависимости от свойства кучи — MinHeap и MaxHeap.
*MinHeap*: родительский узел всегда меньше дочерних узлов.
*MaxHeap*: родительский узел всегда больше или равен дочерним узлам.
Производительность кучи при получении элемента - О(1)

#### Hash таблица
[Wiki](https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)
Структура данных, имеющая интерфейс ассоциативного массива. Хранит пары ключ- значение. Добавляем, удаляем, ищем по ключу.
Коллизии и парадоксы.
Прямая адресация - если известны все ключи элементов.
Коэффициент заполнения хэш таблицы(load factor) - количество  хранимых элементов делённое на количество возможных  хэш-функций(размер массива).
Сложность выполнения трёх операция: добавление, удаление, поиск - выполняется за O(1)
Способы разрешения коллизий:...
#### Связные списки
###### Односвязный
###### Двусвязный




#### Virtual DOM
Менять, перерисовывать  DOM напрямую - невыгодно и дорого. Поэтому мы работаем с V DOM, который является упрощённой легковесной копией DOM. И в зависимости от изменений в V DOM будет перерисовываться DOM!
```ts
React--->Component--->JSX(JS)--->V DOM--->DOM--->User
State--->                    --->V DOMCopy
```
повторная отрисовка V DOM не затирает предыдущую, а создаёт новую копию V Dom. Копии сравниваются между собой, и лишь только разница между ними отрисовывается в DOM. В этом заключается оптимизация всего процесса и смысл использования виртуального DOM.
После сравнивания копий, старая копия затирается, а новая становится на место старой.

#### Node JS
[Dimich](https://www.youtube.com/watch?v=Nvx6OnjVZzU&t=1573s)
Среда разработки JS, основанная на движке V8 Chrome. Та же технология используется и в самом браузере Chrome. Одно другое не заменяет, но существенно дополняет.
Движок V8 использует язык JS и преобразует его в низкоуровневый машинный код, который запускается устройствами без дополнительных интерпретаций.
Node JS работает  с пакетными системами `npm` и `yarn`, которые являются обширными библиотеками с открытым исходным кодом. 
Именно из-за большого количества различных модулей мы и используем в работе Node JS.


#### Swagger
[[Swagger]]
### Бинарный поиск
Эффективный, быстрый алгоритм поиска элемента в отсортированном массиве.
Внимание! Именно в отсортированном предварительно!
Многократное деление массива пополам и сравнивание искомого значения со значением среднего элемента в разделённом массиве. 
Если искомый элемент меньше среднего значения - удаляем правую часть массива и продолжаем работу с левой частью.
Если искомый элемент больше среднего - удаляем левую и ищем в правой
Если искомый равен среднему - возвращаем значение(ключ, индекс элемента).
Продолжаем подобное разбиение пока не останется один элемент.
Если искомый элемент не найден - возвращаем -1
Сложность алгоритма бинарного поиска O (log n). Эффективен для поиска в массивах с большим количеством элементов.
Для небольших массивов лучше воспользоваться линейным алгоритмом поиска O(n). Так для бинарного нужна ещё предварительна сортировка O (n log n)

```js
function binarySearch(sortedArray, key){
    let start = 0;
    let end = sortedArray.length - 1;

    while (start <= end) {
        let middle = Math.floor((start + end) / 2);

        if (sortedArray[middle] === key) {
            // found the key
            return middle;
        } else if (sortedArray[middle] < key) {
            // continue searching to the right
            start = middle + 1;
        } else {
            // search searching to the left
            end = middle - 1;
        }
    }
	// key wasn't found
    return -1;
}
```
### Сложность алгоритмов
[tproger](https://tproger.ru/articles/computational-complexity-explained/)
[habr](https://habr.com/ru/post/444594/)

Сложность алгоритмов оценивается по времени выполнения или объёму используемой памяти.
Учитывается лишь асимптотическая сложность - сложность при стремлении размера входных данных к бесконечности!
В Big O-нотации всегда рассматриваются наихудшие варианты ( искомый эл-т может быть последним в массиве)
n - количество элементов
- O(n) линейная сложность(итерация(время порядка n)) - алгоритм поиска наибольшего элемента неотсортированного массива Чтобы найти нужный элемент, нужно пройтись по всем элементам этого массива. Алгоритм линейно масштабируется.
- O(log n) логарифмическая сложность - бинарный поиск. log n - сколько раз нужно поделить массив, чтобы получить искомое?
- O(n²) или (n^2) квадратичная сложность - цикл в цикле, например. Дважды O(n)
- O(n Log n) - замена цикла внутри цикла на бинарный поиск, т.е бинарный поиск внутри цикла. O(n) + O(log n) = O(n Log n)
- О(1) - сложность не зависит от размера входных данных. Поиск по индексу, например. Алгоритм выполняется за время равное константе.

![[Pasted image 20230131224335.png]]

### two-way binding
[Dimich](https://www.youtube.com/watch?v=8MFKAdG_qb0&list=PLcvhF2Wqh7DPqIlrYFsEtx2TiVfkNiu5l&index=6&t=2875s)
Двусторонняя связь между стейтом и отображением(рендерингом). Меняем стейт - меняетсят UI, меняем что-то в UI - меняется состояние стейта. Данная технология присуща Ангуляру или Вью. 
React имеет одностороннюю связь. Лишь изменив что-то в стейте мы получим изменение в UI (HTML), но не наоборот. Для того, чтобы менять состояние стейта из UI (например из input) нам нужно задействовать обработчик события и функцию setState
В React пытались реализовать двустороннюю связь при помощи `LinkedStateMixin`, но на сегодня это не работает.
### Хранение данных в браузере
#### local storage 
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=820s)
Хранилище данных на стороне браузера. Данные хранятся постоянно, удалиться могут только с переустановкой браузера, или со сносом системы в целом. Размер local storage ограничен. 
! local storage привязан к конкретному домену. Данные разных доменов не пересекаются. 
!Не отправляется с каждым запросом на сервер!
Более удобное и выгодное хранение данных в сравнении с кукой. 
Данные в хранилище отправляются в виде текстового документа JSON (стринглифай)
local storage может переполниться, его объём ограничен.
серрилизация, дессерилизация - термины обозначающие преобразование в строку и обратно.

#### session storage 
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=820s)
Хранилище данных на стороне браузера. Отличается от [[#local storage]] тем, что хранит данные сессионно. Как только закрываем вкладку браузера - данные затираются. Открываем новую вкладку - появляется новое хранилище
session storage привязаlocal storageн к конкретному домену. Данные разных доменов не пересекаются.

#### Куки
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=96s)
Небольшие текстовые файлы (ключ: значение), хранятся в браузере. Привязаны к домену ( для каждого  домена свои куки)
Создаёт куку всегда браузер, кука передаётся на сервер, сервер возвращает куку браузеру с обновлёнными данными. Поэтому можно сказать, что сервер может устанавливать куку.
Кука отправляется на сервер с каждым новым запросом!
На сегодня в куках передаются закодированные авторизационные данные. Или же при помощи куки собирают данные о пользователе. 
Ранее спектр данных был широк, но чем больше кука - тем тяжелее реквест. 
Потому кукам оставили авторизацию, а для остальным данных используется [[#local storage]]

#### Кэш
### document.querySelector
[Dimich](https://www.youtube.com/watch?v=saDuFtwxL4U&t=2080s)
[MDN doc](https://developer.mozilla.org/ru/docs/Web/API/Document/querySelector)

Метод объекта `document`, который позволяет обратиться(найти) к HTML элементу по его селектору, или атрибуту селектора (например селекторы CSS)
По умолчанию возвращает первый элемент в документе, совпадающий с указанным селектором. Поэтому, если в документе несколько элементов с одним селектором, то нужно задавать уточнение(например указывать атрибут)
Если нужно получить все элементы страницы с заданным селектором, то нужно использовать метод `querySelectorAll()`
```js
<div className={s.inputArea}>
document.querySelector(s.inputArea)
document.querySelector('.inputArea')   
document.querySelectorAll('.inputArea')
```
или
```js
<div className={s.btnArea}>  
  <button className={s.btn}> add New Post</button>
document.querySelector('.btnArea.btn') 
```

Позволяет работать с DOM элементами напрямую, через нативный JS!
Можно задать достаточно точные настройки поиска. На примере ниже нашёл кнопку по её классу. Но на странице несколько кнопок с одним классом, поэтому вторым параметром, в квадратных скобках, указал атрибут id нужной кнопки
![[Pasted image 20230227140647.png]]
метод `.innerText` позволяет изменить текст на выбранном элементе.
### Clean Up в useEffect
[Dimich](https://www.youtube.com/watch?v=saDuFtwxL4U&t=976s) 
Функция которая ретурнится из хука, позволяет отписаться от каких-либо сайд эффектов, созданных при помощи того же хука
### Agile VS Waterfall
[Dimich](https://www.youtube.com/watch?v=DjrK3PN2_D4&t=957s) 
Это подходы ведения разработки. и 
Отличие Agile от Waterfall заключается в том, что первая - более гибкая система.
#### Agile 
[Манифест](https://www.atlassian.com/ru/agile/manifesto)
Не имеет чёткого ТЗ или документации. Фичи могут удаляться или добавляться по ходу разработки. Agile более отзывчива к изменениям рынка. Весь период разработки разбивается на промежутки. В рамках одного такого промежутка команда работает над кодом, по итогом выкатывает фичу( сущность, модуль), далее идёт обсуждение и принимаются решения по работе на следующий промежуток времени.
Яркие представители Agile подхода - Scrum и Kanban
##### Scrum
[Atlassian](https://www.atlassian.com/ru/agile/scrum)
Scrum - схватка. Данная методология ориентирована на клиента, адаптивна. У клиента есть возможность вносить изменения в процессе разработки. Scrum - прост в изучение, экономит время, позволяет получить потенциально рабочий продукт в конце каждого sprint.
Идеально подходит для небольших проектов, кампаний
    _Product owner_
    _Scrum master_
    _Development team_
    _Sprint_
    _Backlog_
    _Daily_

##### Kanban
[О Kanban ](https://www.atlassian.com/ru/agile/kanban)
Kanban - визуальный сигнал.
В процессе разработки используются реальные или виртуальные Kanban-доски и Kanban-карточки, помогающие визуализировать процесс разработки.
Полная прозрачность рабочих процессов, обсуждение производительности в реальном времени. Гибкость планирования. 
![[Pasted image 20230328141937.png]]

#### Waterfall
[Подробнее](https://worksection.com/blog/waterfall-vs-agile.html)
Waterfall - водопад. Водопадная система разработки
C самого начала имеет чёткую структуру, сроки разработки. Последовательный переход с одного этапа на другой без пропусков и возвращений на предыдущие стадии. 
Есть ТЗ и документация. Менее отзывчива к изменениям рынка, но разработка ведётся в более спокойном режиме.
### Генератор
Функция которая **последовательно** возвращает разные значения, по мере необходимости.
Для объявления нужно необходимо к ключевому слову function добавить звёздочку `*`.
`function getGenerator(){}`
После появляется возможность использовать внутри тела функции одно из ключевых слов.
`yield` - по своим свойствам похоже на return.
```js
function* getStat(){  
    yield 1  
    yield 2  
    return 3  
}
const generator = getStat()
```
generator - это объект и один из его методов это .next()
```js
console.log(generator.next()) // { value: 1, done: false }  
```
Данный лог вернёт объект, value его значение, а done указывает является ли оно последним.
Следующий вызов вернёт
```js
{ value: 2, done: false }
```
Третий вызов вернёт 
```js
{ value: 3, done: true } // этот объект последний            

```
Последующий вызов вернёт
```js
{ value: undefined, done: true } 
```
Генераторы, как и обычная функция могут принимать аргументы и содержать в себе сложную логику.

### Коллекции Map и SET
**Object** - хранит коллекции именованных значений(пары ключ:значение). В Ключ имеет тип строчный. Любые иные типы ключей преобразуются объектом в строчные.
**Array** - хранит коллекции упорядоченных(индексы) значений.
**Map** - очень похож на Object, но в качестве ключа может выступать любой тип.
!! Map позволяет использовать объект в качестве ключа !!
!! Map  позволяет использовать NaN в качестве ключа !!
!! Перебор элементов Map происходит по порядку. Map упорядоченная коллекция !!
**Set** - коллекция значений, ключи отсутствуют. Каждое значение - уникально и появляется в коллекции лишь раз. Set автоматически проводит проверку на уникальность. 
Set идеален для добавления! Хранить значения можно и в массиве, но для проверки уникальности нужно будет использовать метод массива fined, что приводит к ухудшению производительности, в сравнении с Set!
### Методы for in  и for of
Операторы которые производят обход объектов(объекты, массивы, строки, Map, Set, генераторы...).
Отличие заключается в том, что for in осуществляет обход свойств в произвольном порядке, а в соответствии с определённым порядком.
Оператор for of не работает с обычными объектами, так как свойства в нём сложены в произвольном порядке.
### boxing и unboxing
Упаковка примитива в объект и наоборот соответственно.

### Eval func
[MDN Doc](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/eval)

Метод(функция) eval() выполняет JS код, представленный строкой
```js
eval('2 + 2') // 4
```
Функция устаревшая, сильно нагружающая систему(дорогая), медленная и небезопасная.
Есть более современные и экономичные методы, которые могут справиться с задачами eval.
Но, если eval встречается в проекте со старым кодом, то  с ней нужно быть осторожнее. Если вы запускаете `eval()` со строкой, на которую могут влиять злоумышленники, то вы можете запустить вредоносный код на устройство пользователя