[Dimich](https://www.youtube.com/watch?v=xRe0hbu6qJw&ab_channel=IT-KAMASUTRA) - Деструктуризация присваивания
[[#Деструктуризация объекта]]
[[#Деструктуризация массива]]
[[#Деструктуризация функции]]
## Деструктуризация объекта

Деструктуризация объекта даёт возможность обратиться к свойствам объекта, и на основании их создать новые переменные, избегая написание избыточного кода
```js
const myName = { name: 'Alex', name_2: 'Bob' }
const {name, name_2} = myName
console.log(name) //Alex 
```

Используя подобную запись, мы говорим, что берём свойства объекта myName, создаём переменные с именами аналогичными именам свойств объекты, и присваиваем этим переменным значения, аналогичные значениям свойств объекта

## Деструктуризация массива
[Dimich](https://youtu.be/xRe0hbu6qJw)
[useState под капотом](https://youtu.be/xRe0hbu6qJw)

Деструктуризация массива проходит аналогично [[Деструктуризация объекта]], за исключением того что объявленные переменные обрамляются уже квадратными скобками. И, поскольку массив - это объект с цифровыми именами свойств, то обратиться к свойству по имени уже не получится. Мы сами задаём имена переменных, следуя тому, что порядок элементов в массиве важен, строго по порядку элементов массива. 

```js
const myEkip = ['mask', 'fins', 'snorkel'] 
const [ekip_1, ekip_2, ekip_3] 
console.log(ekip_2) //fins
```

Если нужно забрать не все элементы массива, а лишь некоторые, то проставляем наименование переменных согласно очерёдности их индексов в массиве, и не нужные указываем пустотами через запятую 
```js
const [ , , ekip_3]
```

useState работает по похожему алгоритму.
Если нам нужно Забрать несколько элементов из массива, в качестве переменных, а остальные элементы не нужны в данный момент, но могут понадобиться в будущем - можно воспользоваться принципом **rest** (остаточные переменные) 
```js
const [ekip_2, ...rectEkip]
```
 
При помощи подобной записи мы объявляем переменную ekip_2, а остальные элементы помещаем в ...rectEkip, и можем обратиться к ним позже при помощи точечной записи.
[способы пропуска элементов](https://youtu.be/xRe0hbu6qJw?t=2516) 
Данная методология редко используется в продакте, но с её помощью можно писать [[кастомный хук]], например.

[фича тля теста вложенности](https://youtu.be/xRe0hbu6qJw?t=2749)

## Деструктуризация функции
[Остаточные переменные. rest](https://youtu.be/xRe0hbu6qJw?t=1589) 
Деструктуризация функции происходит в параметрах функции, и уже затем мы можем обратиться к новым переменным внутри функции. 
```js
const myEkip = ({'mask', 'fins', 'snorkel'}) =>{ 
 let mask= 
	}
```
