[[#метод "map" 13:52]]
[[#Удаление таски / onClick 19:03]]
[[#Функция удаления таски / filter 30:10]]
[[#Local State (useState) 43:06]]
[[#Фильтрация задач (all active completed) 1:04:21]]
[[#uuid. Подключение библиотеки 2:11]]
7:48 - про key
[[#ADD TASK. Добавляем таску по нажатию кнопки 9:18]]
[[#Чтение значения из input 17:05]]
[[#Очистка поля input (onChange) 29:13]]
[[#Добавление таски по нажатию на Enter 30:09]]


## 01_02 - TodoList for students
[Dimich](https://samurai.it-incubator.io/pc/video-content/watch/60b5104ef084890015872dbe)
#### Метод "map" **13:52** 
Для прохода по массиву тасок используем метод map. 
Внутри ul обращаемся к приходящему в props массиву тасок посредством map.
!!! Нужно помнить , что это уже JSX и поэтому весь блок кода оборачиваем фигурными скобками!!!
Коллбэк в map типизируем как TasksType (если тип задан, то сама ide подскажет).
 Помещаем одну из li в return map. 
 !!! В метода map в обязательном порядке указываем атрибут key для возвращаемого элемента. Это поможет React работать эффективно при итерации по массиву и при добавлении или удалении элементов из массива. Без атрибута key react может работать некорректно. 
 Подробно об [key](obsidian://open?vault=obsidian-storage&file=4_React%2FReact)  !!! 
 В самой li уже обращаемся не через props  (поскольку сам метод map уже в props), а напрямую к итерируемому элементу массива.
 Остальные li можно удалять.
 
#### Удаление таски / onClick 19:03
Добавляем button внутрь отрисовываемой map li.
На button вешаем обработчик события onClick.
!!! Помним, что в onClick помещаем функцию callback которая будет вызываться при  нажатии на кнопку. Не забываем про `()=>{}`!!!

##### Функция удаления таски / filter 30:10
В той же компоненте где находятся данные, создаём функцию удаления таски из массива. 
Каким образом понять какую именно таску нужно будет удалить функции, при срабатывании onClick в UI? Для этого нужно будет функции принять входным параметром id таски. Обязательно входной параметр протипизировать!!
В теле функции присваиваем нашему массиву тасок новое значение. Это значение будет получено путём фильтрации исходного массива. Новый массив будет принимать только те таски id которых не равно id приходящему в параметрах.
Далее прокидываем функцию удаление атрибутом в компоненту Todolist, типизируем её в компоненте как метод, который принимает в себе 
`id: number` и возвращающим пустоту `void`
В onClick кнопки помещаем приходящую в пропсах функцию удаления, и в её вызов помещаем id таски на которую было произведён клик.

#### Local State (useState) 43:06
На данный момент фильтрация происходит, и таски удаляются в панели браузера, но визуальная перерисовка состояния не происходит, потому как react не видит, что мы изменяем что-либо.
Для того, чтобы дёрнуть react нам нужно воспользоваться локальным стейтом и хранить наш BLL в нём. 
Для этой задачи подходит хук useState именно в его стартовое значение помещаем наш массив с данными.
Теперь, когда нам нужно будет дёрнуть react для перерисовки, воспользуемся функцией setState, в вызов которой поместим State
```js
let [tasks,setTasks] =useState([  
  {id: 1, title: 'HTML&CSS', isDone: true},  
  {id: 2, title: 'JS', isDone: true},  
  {id: 3, title: 'ReactJS', isDone: false},  
  {id: 4, title: 'Rest API', isDone: true},  
  {id: 5, title: 'GraphQL', isDone: false},  
])  
  
  const removeTasks = (id: number) => {  
    tasks = tasks.filter(t => t.id !== id)  
    setTasks(tasks)  
  }
```

#### Фильтрация задач (all | active | completed) 1:04:21
Для того, чтобы иметь возможность фильтровать таски по нажатию кнопки и перерисовывать состояние компоненты, нам так же пригодиться useState.
Создадим его с начальным состояние 'All', то есть по умолчанию он будет отрисовывать все таски.
Далее создаём переменную, в которую копируем (помещаем) все наши таски
```js
let filteredTasks = tasks
```
Создаём условие при помощи if(). В котором говорим, что если filter useState будет строго равен 'Active' то пробегись методом фильтр по таскам и верни таски со значением isDone равным false. И если filter useState будет строго равен 'Comleted' то пробегись методом фильтр по таскам и верни таски со значением isDone равным true.
Результаты выполнения условий присваиваем ранее созданной переменной и отправляем её атрибутом в компонент Todolist.
![[Pasted image 20230329154759.png]]
На данный момент мы моем вручную менять визуальное состояние компонента, прописывая в стартовое значения стейта иные фильтры.
Для начала создадим в Bll компоненте тип для всех возможных состояний.
Этим же типом будем типизировать локальный стейт фильтра.(в дженериках)
![[Pasted image 20230329163704.png]]
В BLL компоненте создаём функцию меняющую состояние фильтра. Во входящих параметрах она принимает возможное value тип, который будет ранее созданный. В теле функции вызываем функцию setState и в её вызов помещаем приходящее value.
Прокидываем функцию атрибутом в компонент todo. Там её типизируем как метод принимающий value: ChangeFilterType и возвращающий пустоту(ничего)
Вешаем обработчики события onClick на кнопки фильтрации состояния тасок. В onClick помещаем функцию изменения состояния фильтра, приходящую в пропсах. В её вызов помещаем соответствующее кнопке состояние.
Фильтрация происходит.

## 03 - TodoList for students
[Dimich](https://samurai.it-incubator.io/pc/video-content/watch/60b510c6f084890015872dbf)

#### UUID. Подключение библиотеки 2:11
UUID - библиотека, которая генерирует текстовые, уникальные id
Подключение к проекту
```ts
yarn add uuid @types/uuid
```
!!! Везде где фигурировал id:number - заменить на string.

#### ADD TASK. Добавляем таску по нажатию кнопки 9:18
В BLL компоненте создаём функцию добавления таски в наш массив(стейт). В параметрах она ничего не принимает. 
В теле создаём переменную для новой таски и присваиваем ей сгенерированную на коленке таску (copy/paste).
Создаём ещё одну переменную и присваиваем ей новый массив, в который сначала помещаем новую таску, и затем все таски из исходного стейта.( при помощи деструктуризации исходного массива)
Для того, чтобы при нажатии кнопки кнопки, визуально отображалось изменение состояния, вызываем функцию setState и в её вызов помещаем наш новый массив тасок.
![[Pasted image 20230329210243.png]]
Далее прокидываем функцию атрибутом в компонент todo, там её типизируем как метод не принимающий ничего и возвращающий пустоту void.
На кнопку добавления таски вешаем обработчик onClick и в его колбэк помещаем пришедшую в пропсах функцию добавления таски.
!!! Не забываем про круглые скобки за функцией в колбэке onClick. Если есть скобки слева, то должны быть и справа!!!
На данном этапе, при нажатии на кнопку должна отображаться новая добавившаяся таска.

#### Чтение значения из input 17:05
Нужно отрисовывать то значение, что вводиться в инпуте, а не зашитое нами.
Создаём локальный стейт в компоненте с инпутом, его стартовым значением будет пустая строка. Он будет отвечать за изменение в инпуте и отрисовывать их.
На инпут вешаем обработчик событий onChange с колбэком внутри, и атрибут value - его значением будет неизменённое состояние локального стейта.
В колбэк onChange помещаем событие интерфейса event, типизируем его как `e:ChangeEvent<HTMLInputElement>`, а в теле колбэка вызываем функцию setState и в её вызове привязываем наш инпут к событию onChange `e.currentTarget.value`
Дабы не загромождать обработчик кодом, всю логику можно вынести наверх, в созданную для этого функцию Handler.
После этого, на кнопке добавления таски, в её обработчике, в вызов функции добавления таски можно добавить состояние нашего локального стейта.
![[Pasted image 20230329222022.png]]
Таким образом, при клике на кнопку добавления таски, мы будем отрисовывать вводимое value в инпуте.
Это value ещё нужно прокинуть наверх, в BLL компоненту, и при создании новой таски указывать не вшитое значение, а пришедшее value из инпута.
Прокидывая value наверх, не забываем его типизировать в пропсах как string, и в входных параметрах функции  добавления новой таски.

#### Очистка поля input (onChange) 29:13
Для того, чтобы после добавления новой таски поле ввода инпута зачищалось, нужно в обработчик onClick кнопки добавления передать функцию setState локального стейта состояния инпута, и в её вызов поместить пустую строку.

#### Добавление таски по нажатию на Enter 30:09
Для того, чтобы новая таска добавлялась по нажатию на клавиши клавиатуры, нужно на инпут повесить обработчик события [onKeyDown](https://developer.mozilla.org/ru/docs/Web/API/Element/keydown_event).
В колбэк обработчика помещаем функцию Handler, а её логику выносим наверх.
Во входящих параметрах принимаем интерфейс event и типизируем его как `e: KeyboardEvent<HTMLInputElement>`
В теле функции создаём инструкцию if, условие которой; если key(клавиша) события интерфейса event будет строго равна, к примеру, 'Enter', то верни приходящую пропсами функцию добавления таски, в вызове которой будет состояние стейта, а так же верни логику затирания инпута после ввод ( в общем - верни логику лежащую в логике button).
![[Pasted image 20230330123830.png]]
По сути можно в теле инструкции if сделать вызов функции добавления новой таски!
![[Pasted image 20230330131900.png]]

[37:51](https://www.youtube.com/watch?v=jh2XvRX7fw4&t=2271s) - рефактор кода
[47:37](https://www.youtube.com/watch?v=jh2XvRX7fw4&t=2857s) - рефактор функции удаления
[9:01](https://youtu.be/ut7SbOKilZE) – Aктивный чекбокс
[32:10](https://youtu.be/ut7SbOKilZE?t=1935) – trim() Убрать пробелы и пустые строки
[39:00](https://youtu.be/ut7SbOKilZE?t=2347) – title is required. Ошибка пустого ввода
[47:50](https://youtu.be/ut7SbOKilZE?t=2902) – подсветка кнопок выполненных тасок
[53:54](https://youtu.be/ut7SbOKilZE?t=3114) - затенение выполненных тасок
[12:00](https://www.youtube.com/watch?v=mF6NfolktTY&t=720s) – массив todolists
[16:20](https://www.youtube.com/watch?v=mF6NfolktTY&t=980s) – фильтрация тасок для каждого todolist
[18:49](https://youtu.be/mF6NfolktTY?t=1131) - коррекция функции изменения фильтра

[23:52](https://youtu.be/mF6NfolktTY?t=1432) - помещаем переменную с тудулистами в useState
[24:29](https://youtu.be/mF6NfolktTY?t=1495) - модифицируем функцию изменения фильтра  
[29:00](https://www.youtube.com/watch?v=mF6NfolktTY&t=1740s) – где хранить таски
[37:39](https://youtu.be/mF6NfolktTY?t=2272) - чиним функции над return
[44:45](https://www.youtube.com/watch?v=mF6NfolktTY&t=2685s) – debugger
[47:00](https://www.youtube.com/watch?v=mF6NfolktTY&t=2820s) – удаление todolists
[49:40](https://www.youtube.com/watch?v=mF6NfolktTY&t=2980s) – удаление todolist tasks из стейта
[1:00](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=60s), [2:40](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=160s) – переиспользование input
[13:30](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=810s) – обертка addTask
[18:30](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1110s) – добавляем новый todolist
[21:00](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1260s) – типизация tasksObj

[28:20](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1700s) – редактирование span
[32:16](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1936s) – EditableSpan
[53:30](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=3210s) – редактирование todolist name
[58:00](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=3480s) – debugger (как работает editable span)
[59:40](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=3580s) – резюме (рисовалка)

## material-ui
[20:00](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=1200s) – кнопки
[23:40](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=1420s) – инпут
[31:35](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=1895s) – чекбокс
[44:30](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=2670s) – AppBar
[47:10](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=2830s) – Container, grid
## reducer
[8:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=480s) – как работает reducer 
[10:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=600s) – начало. игрушечные тесты
[19:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=1140s) – тесты для reducer
[26:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=1590s) – иммутабельность для редьюсера
[30:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=1830s) – TDD (test-driven development)
[38:10](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=2290s) – reducers for todolists
[40:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=2430s) – тесты для todolist reducers
[58:40](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=3520s) – типизация actions
[1:07:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=4020s) – action creators
[1:18:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=4710s) – debugger
## Reducer for tasks [Клац](https://samurai.it-incubator.ru/pc/video-content/watch/60b52128f084890015872df5)
**14:40** – начало  
**21:40** – тесты
31:35 - добавление таски
56:37 - стейт тасок при добавлении тудулиста
1:00:00 - объяснение структуры теста

Удаление тасок
#Удаление_тасок


Фильтрация состояния тасок
#фильтрация_тасок





