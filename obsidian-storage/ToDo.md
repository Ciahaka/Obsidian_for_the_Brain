[[#метод "map" 13:52]]
[[#Удаление таски / onClick 19:03]]
[[#Функция удаления таски / filter 30:10]]
[[#Local State (useState) 43:06]]
[[#Фильтрация задач (all active completed) 1:04:21]]
[[#uuid. Подключение библиотеки 2:11]]
7:48 - про key
[[#ADD TASK. Добавляем таску по нажатию кнопки 9:18]]
[[#Чтение значения из input 17:05]]
[[#Очистка поля input (onChange) 29:13]]
[[#Добавление таски по нажатию на Enter 30:09]]
[[#Рефакторинг кода 37:51]]
[[#Активный чекбокс 8:55]]
[[#trim(). Защита от пустого ввода 32:10]]
[[#Title is required! Предупреждение о неверном вводе 39:00]]

## 01_02 - TodoList for students
[Dimich](https://samurai.it-incubator.io/pc/video-content/watch/60b5104ef084890015872dbe)
#### Метод "map" **13:52** 
Для прохода по массиву тасок используем метод map. 
Внутри ul обращаемся к приходящему в props массиву тасок посредством map.
!!! Нужно помнить , что это уже JSX и поэтому весь блок кода оборачиваем фигурными скобками!!!
Коллбэк в map типизируем как TasksType (если тип задан, то сама ide подскажет).
 Помещаем одну из li в return map. 
 !!! В метода map в обязательном порядке указываем атрибут key для возвращаемого элемента. Это поможет React работать эффективно при итерации по массиву и при добавлении или удалении элементов из массива. Без атрибута key react может работать некорректно. 
 Подробно об [key](obsidian://open?vault=obsidian-storage&file=4_React%2FReact)  !!! 
 В самой li уже обращаемся не через props  (поскольку сам метод map уже в props), а напрямую к итерируемому элементу массива.
 Остальные li можно удалять.
 
#### Удаление таски / onClick 19:03
Добавляем button внутрь отрисовываемой map li.
На button вешаем обработчик события onClick.
!!! Помним, что в onClick помещаем функцию callback которая будет вызываться при  нажатии на кнопку. Не забываем про `()=>{}`!!!

##### Функция удаления таски / filter 30:10
В той же компоненте где находятся данные, создаём функцию удаления таски из массива. 
Каким образом понять какую именно таску нужно будет удалить функции, при срабатывании onClick в UI? Для этого нужно будет функции принять входным параметром id таски. Обязательно входной параметр протипизировать!!
В теле функции присваиваем нашему массиву тасок новое значение. Это значение будет получено путём фильтрации исходного массива. Новый массив будет принимать только те таски id которых не равно id приходящему в параметрах.
Далее прокидываем функцию удаление атрибутом в компоненту Todolist, типизируем её в компоненте как метод, который принимает в себе 
`id: number` и возвращающим пустоту `void`
В onClick кнопки помещаем приходящую в пропсах функцию удаления, и в её вызов помещаем id таски на которую было произведён клик.

#### Local State (useState) 43:06
На данный момент фильтрация происходит, и таски удаляются в панели браузера, но визуальная перерисовка состояния не происходит, потому как react не видит, что мы изменяем что-либо.
Для того, чтобы дёрнуть react нам нужно воспользоваться локальным стейтом и хранить наш BLL в нём. 
Для этой задачи подходит хук useState именно в его стартовое значение помещаем наш массив с данными.
Теперь, когда нам нужно будет дёрнуть react для перерисовки, воспользуемся функцией setState, в вызов которой поместим State
```js
let [tasks,setTasks] =useState([  
  {id: 1, title: 'HTML&CSS', isDone: true},  
  {id: 2, title: 'JS', isDone: true},  
  {id: 3, title: 'ReactJS', isDone: false},  
  {id: 4, title: 'Rest API', isDone: true},  
  {id: 5, title: 'GraphQL', isDone: false},  
])  
  
  const removeTasks = (id: number) => {  
    tasks = tasks.filter(t => t.id !== id)  
    setTasks(tasks)  
  }
```

#### Фильтрация задач (all | active | completed) 1:04:21
Для того, чтобы иметь возможность фильтровать таски по нажатию кнопки и перерисовывать состояние компоненты, нам так же пригодиться useState.
Создадим его с начальным состояние 'All', то есть по умолчанию он будет отрисовывать все таски.
Далее создаём переменную, в которую копируем (помещаем) все наши таски
```js
let filteredTasks = tasks
```
Создаём условие при помощи if(). В котором говорим, что если filter useState будет строго равен 'Active' то пробегись методом фильтр по таскам и верни таски со значением isDone равным false. И если filter useState будет строго равен 'Comleted' то пробегись методом фильтр по таскам и верни таски со значением isDone равным true.
Результаты выполнения условий присваиваем ранее созданной переменной и отправляем её атрибутом в компонент Todolist.
![[Pasted image 20230329154759.png]]
На данный момент мы моем вручную менять визуальное состояние компонента, прописывая в стартовое значения стейта иные фильтры.
Для начала создадим в Bll компоненте тип для всех возможных состояний.
Этим же типом будем типизировать локальный стейт фильтра.(в дженериках)
![[Pasted image 20230329163704.png]]
В BLL компоненте создаём функцию меняющую состояние фильтра. Во входящих параметрах она принимает возможное value тип, который будет ранее созданный. В теле функции вызываем функцию setState и в её вызов помещаем приходящее value.
Прокидываем функцию атрибутом в компонент todo. Там её типизируем как метод принимающий value: ChangeFilterType и возвращающий пустоту(ничего)
Вешаем обработчики события onClick на кнопки фильтрации состояния тасок. В onClick помещаем функцию изменения состояния фильтра, приходящую в пропсах. В её вызов помещаем соответствующее кнопке состояние.
Фильтрация происходит.

## 03 - TodoList for students
[Dimich](https://samurai.it-incubator.io/pc/video-content/watch/60b510c6f084890015872dbf)

#### UUID. Подключение библиотеки 2:11
UUID - библиотека, которая генерирует текстовые, уникальные id
Подключение к проекту
```ts
yarn add uuid @types/uuid
```
!!! Везде где фигурировал id:number - заменить на string.

#### ADD TASK. Добавляем таску по нажатию кнопки 9:18
В BLL компоненте создаём функцию добавления таски в наш массив(стейт). В параметрах она ничего не принимает. 
В теле создаём переменную для новой таски и присваиваем ей сгенерированную на коленке таску (copy/paste).
Создаём ещё одну переменную и присваиваем ей новый массив, в который сначала помещаем новую таску, и затем все таски из исходного стейта.( при помощи деструктуризации исходного массива)
Для того, чтобы при нажатии кнопки кнопки, визуально отображалось изменение состояния, вызываем функцию setState и в её вызов помещаем наш новый массив тасок.
![[Pasted image 20230329210243.png]]
Далее прокидываем функцию атрибутом в компонент todo, там её типизируем как метод не принимающий ничего и возвращающий пустоту void.
На кнопку добавления таски вешаем обработчик onClick и в его колбэк помещаем пришедшую в пропсах функцию добавления таски.
!!! Не забываем про круглые скобки за функцией в колбэке onClick. Если есть скобки слева, то должны быть и справа!!!
На данном этапе, при нажатии на кнопку должна отображаться новая добавившаяся таска.

#### Чтение значения из input 17:05
Нужно отрисовывать то значение, что вводиться в инпуте, а не зашитое нами.
Создаём локальный стейт в компоненте с инпутом, его стартовым значением будет пустая строка. Он будет отвечать за изменение в инпуте и отрисовывать их.
На инпут вешаем обработчик событий onChange с колбэком внутри, и атрибут value - его значением будет неизменённое состояние локального стейта.
В колбэк onChange помещаем событие интерфейса event, типизируем его как `e:ChangeEvent<HTMLInputElement>`, а в теле колбэка вызываем функцию setState и в её вызове привязываем наш инпут к событию onChange `e.currentTarget.value`
Дабы не загромождать обработчик кодом, всю логику можно вынести наверх, в созданную для этого функцию Handler.
После этого, на кнопке добавления таски, в её обработчике, в вызов функции добавления таски можно добавить состояние нашего локального стейта.
![[Pasted image 20230329222022.png]]
Таким образом, при клике на кнопку добавления таски, мы будем отрисовывать вводимое value в инпуте.
Это value ещё нужно прокинуть наверх, в BLL компоненту, и при создании новой таски указывать не вшитое значение, а пришедшее value из инпута.
Прокидывая value наверх, не забываем его типизировать в пропсах как string, и в входных параметрах функции  добавления новой таски.

#### Очистка поля input (onChange) 29:13
Для того, чтобы после добавления новой таски поле ввода инпута зачищалось, нужно в обработчик onClick кнопки добавления передать функцию setState локального стейта состояния инпута, и в её вызов поместить пустую строку.

#### Добавление таски по нажатию на Enter 30:09
Для того, чтобы новая таска добавлялась по нажатию на клавиши клавиатуры, нужно на инпут повесить обработчик события [onKeyDown](https://developer.mozilla.org/ru/docs/Web/API/Element/keydown_event).
В колбэк обработчика помещаем функцию Handler, а её логику выносим наверх.
Во входящих параметрах принимаем интерфейс event и типизируем его как `e: KeyboardEvent<HTMLInputElement>`
В теле функции создаём инструкцию if, условие которой; если key(клавиша) события интерфейса event будет строго равна, к примеру, 'Enter', то верни приходящую пропсами функцию добавления таски, в вызове которой будет состояние стейта, а так же верни логику затирания инпута после ввод ( в общем - верни логику лежащую в логике button).
![[Pasted image 20230330123830.png]]
По сути можно в теле инструкции if сделать вызов функции добавления новой таски!
![[Pasted image 20230330131900.png]]

#### Рефакторинг кода 37:51
Включает в себя вынос всей логики из обработчиков событий наверх, в функции Handler.
!! Внутри ретурна map забираем логику из обработчика и выносим в Handler на ретурном map. Не выше.!!
!! Помещая функции Handler в обработчики, не забываем делать им вызов!!


[47:37](https://www.youtube.com/watch?v=jh2XvRX7fw4&t=2857s) - рефактор функции удаления
[9:01](https://youtu.be/ut7SbOKilZE) – Aктивный чекбокс
[32:10](https://youtu.be/ut7SbOKilZE?t=1935) – trim() Убрать пробелы и пустые строки
[39:00](https://youtu.be/ut7SbOKilZE?t=2347) – title is required. Ошибка пустого ввода
[47:50](https://youtu.be/ut7SbOKilZE?t=2902) – подсветка кнопок выполненных тасок
[53:54](https://youtu.be/ut7SbOKilZE?t=3114) - затенение выполненных тасок
[12:00](https://www.youtube.com/watch?v=mF6NfolktTY&t=720s) – массив todolists
[16:20](https://www.youtube.com/watch?v=mF6NfolktTY&t=980s) – фильтрация тасок для каждого todolist
[18:49](https://youtu.be/mF6NfolktTY?t=1131) - коррекция функции изменения фильтра

[23:52](https://youtu.be/mF6NfolktTY?t=1432) - помещаем переменную с тудулистами в useState
[24:29](https://youtu.be/mF6NfolktTY?t=1495) - модифицируем функцию изменения фильтра  
[29:00](https://www.youtube.com/watch?v=mF6NfolktTY&t=1740s) – где хранить таски
[37:39](https://youtu.be/mF6NfolktTY?t=2272) - чиним функции над return
[44:45](https://www.youtube.com/watch?v=mF6NfolktTY&t=2685s) – debugger
[47:00](https://www.youtube.com/watch?v=mF6NfolktTY&t=2820s) – удаление todolists
[49:40](https://www.youtube.com/watch?v=mF6NfolktTY&t=2980s) – удаление todolist tasks из стейта
[1:00](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=60s), [2:40](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=160s) – переиспользование input
[13:30](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=810s) – обертка addTask
[18:30](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1110s) – добавляем новый todolist
[21:00](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1260s) – типизация tasksObj

[28:20](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1700s) – редактирование span
[32:16](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=1936s) – EditableSpan
[53:30](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=3210s) – редактирование todolist name
[58:00](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=3480s) – debugger (как работает editable span)
[59:40](https://www.youtube.com/watch?v=Q-TPmODeF2M&t=3580s) – резюме (рисовалка)

## 04 - TodoList for students
[Dimich](https://samurai.it-incubator.io/pc/video-content/watch/60b51364f084890015872dc7)
Ликбез: Процесс запуска проекта в WS
При вводе команды yarn start мы запускаем Webpack. Он анализирует все файлы кода, импорты и экспорты и после собирает это всё в один файл.
Далее Webpack запускает транспилятор Babel. Тот, в свою очередь, преобразует всю JSX разметку проекта в язык JS.
Следующим шагом Webpack запускает локальный сервер на устройстве. Сервер даёт браузеру HTML. После подтягивается транспилированый JS и запускается (отображается) приложение.
#### Активный чекбокс 8:55
Для того, чтобы визуально менялся чекбокс нужной таски по клику на него (атрибут cheked в чекбоксе), нам нужно менять значение соответствующего свойства(isDone) объекта таски в BLL компоненте.
Соответственно и функцию создаём в BLL компоненте.
Нам нужно найти таску в массиве данных, у которой нужно изменить значение одного из свойств.
В теле функции воспользуемся методом fined, обращаясь к исходному массиву. Пробегая методом по массиву  ищем id элемента массива который будет строго равен приходящему извне в функцию id.
Результат этого выражения присваиваем переменной.
На этом моменте нужно во входящих параметрах функции задать id(наименование произвольное) и протипизировать его. Это будет id той самой таски на которую кликнули в UI!
Из-за того, что typescript считает, что мы можем передать несуществующее id, нужно провести проверку условием if. 
Говорим, что если существует таска полученная путём фильтрации исходного массива, то её значению isDone присваивается значение isDone пришедшее в параметрах функции.
Указываем в параметрах функции приходящее isDone и типизируем его.
Для того, чтобы react заметил изменения и отрисовал их вызываем функцию setState и в её вызов помещаем копию массива state.
Прокидываем функцию атрибутом в дочернюю компоненту. там типизируем её в пропсах.
Чекбоксу назначаем обработчик события onChange, в его вызов помещаем функцию Handler. Саму функцию выносим из return, но оставляем в map, поскольку её нужно применять для каждого элемента массива!!
Поскольку onChange - событие интерфейса event, то указываем event во входящих параметрах и типизируем его как `e:ChangeEvent<HTMLInputElement>`
Привязываем событие к чекбоксу посредством `e.currentTarget.checked` (берём состояние checked именно на этом элементе). Это выражение присваиваем переменной. А саму переменную помещаем в вызов пришедшей в пропсах функции изменения статуса чекбокса. Туда же помещаем id элемента массива на котором произошло событие.

#### trim(). Защита от пустого ввода 32:10
Метод [[trim]] является общим методом который может удалять пробельные символы в начале и в конце строки. Возвращает строку с вырезанными пробелами с обоих концов, не изменяя при этом саму строку. Поскольку метод общий, то может быть применён не только к строкам!
Нам нужно ограничить для UI возможность ввода пустой строки в инпут и строки с пробелами в начале и в конце.
Первая проблема решается добавлением условия if в функции добавления таски (Handler) в дочерней компоненте. Говорим: если состояние стейта, с применённым к нему методом trim не равно пустой строке, то верни логику функции.
Вторая проблема решается там же, но путём добавления метода trim в вызов пришедшей в пропсах функции добавления таски.
![[Pasted image 20230330195325.png]]

#### Title is required! Предупреждение о неверном вводе 39:00
Сообщение об ошибках нужно где-то хранить, используем для этого локальный стейт. Создаём стейт в дочерней компоненте, поскольку нам ничего не нужно менять в BLL!
Стартовым значением может быть как строка(при условии, что ошибка есть), так и null(при условии, что ошибки нет)
Со старта считаем, что ошибки нет и стартовым значением указываем null. Обязательно типизируем стейт дженериками, в которых прописываем, что стейт может быть строкой или null.
Нужно создать сообщение об ошибке, где-то его разместить, а так же подсвечивать инпут и само сообщение контрастным цветом.
В модуле стилей прописываем стиль для инпута, определяя его бордер красным цветом.
Прописываем стиль для сообщения об ошибке, делая текст сообщения красным.
Div с отрисовкой сообщения можно разместить под кнопкой  добавления новой таски. Для того, чтобы это сообщение появлялось только в случае ошибки, используем инфиксный оператор &&. Данный оператор возвращает первый операнд с false.
![[Pasted image 20230330211219.png]]
 Eсли error нет(false), то операнд прекращает работу и до div с сообщением дело не доходит.
 Если error есть, то оператор вернёт второй операнд и появиться сообщение об ошибке.
 В инпуте вешаем атрибут className. Его значением будет тернарный оператор.
![[Pasted image 20230330211632.png]]
Если есть ошибка, то верни стиль для ошибки, иначе ничего не делай.
Само сообщение помещаем в вызов функции setState и добавляем его как else в условие функции Handler добавления таски.
Для того, чтобы занулять состояние стейта после возникновения ошибки необходимо добавить в Handler функции добавления таски по нажатию кнопки, функцию setState с null в её вызове.
!!!Добавляем на самый верх, над условием if. Это важно. Как только мы что-то нажали на клавиатуре - сразу обнулили стейт и пропала ошибка.!!!
 
#### Подсветка(стилизация) кнопок фильтра. 47:50
В UI, при нажатии на кнопку фильтрации тасок, кнопка должна подсвечиваться цветом, давая понимание пользователю о том где он находиться.
Для того, чтобы это реализовать, нужно воспользоваться состоянием локального стейта фильтра тасок из BLL компоненты.
Для этого нужно прокинуть стейт атрибутом в дочернюю компоненту.
Во входящих пропсах типизируем её так же как и сам прокинутый стейт.
Создаём в стилях свойство для активного состояния кнопки, определяем его цвет. Скажем `.active{ background-color: green}`.
Далее на каждую кнопку фильтра вешаем атрибут className и внутри, тернарным оператором, прописываем условие: что если, пришедший в пропсах стейт будет строго равен соответствующему кнопке состоянию фильтра, то верни стиль 'active', иначе пустую строку(ничего не делай).
![[Pasted image 20230331124359.png]]

#### Затенение выполненных тасок. 51:55
Создаём стиль для этой задачи. В стиле прописываем свойство прозрачности (opacity) со значение 50% или 0.5.


## material-ui
[20:00](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=1200s) – кнопки
[23:40](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=1420s) – инпут
[31:35](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=1895s) – чекбокс
[44:30](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=2670s) – AppBar
[47:10](https://www.youtube.com/watch?v=zNbqQty3O1Q&t=2830s) – Container, grid
## reducer
[8:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=480s) – как работает reducer 
[10:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=600s) – начало. игрушечные тесты
[19:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=1140s) – тесты для reducer
[26:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=1590s) – иммутабельность для редьюсера
[30:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=1830s) – TDD (test-driven development)
[38:10](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=2290s) – reducers for todolists
[40:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=2430s) – тесты для todolist reducers
[58:40](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=3520s) – типизация actions
[1:07:00](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=4020s) – action creators
[1:18:30](https://www.youtube.com/watch?v=5AeVQOpvYEA&t=4710s) – debugger
## Reducer for tasks [Клац](https://samurai.it-incubator.ru/pc/video-content/watch/60b52128f084890015872df5)
**14:40** – начало  
**21:40** – тесты
31:35 - добавление таски
56:37 - стейт тасок при добавлении тудулиста
1:00:00 - объяснение структуры теста

Удаление тасок
#Удаление_тасок


Фильтрация состояния тасок
#фильтрация_тасок





